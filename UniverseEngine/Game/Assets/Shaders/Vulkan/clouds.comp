#version 450
#extension GL_KHR_vulkan_glsl: enable

#define NUM_STEPS 200

layout (binding = 0, rgba8) uniform image2D outputImage;

layout(binding = 1) uniform UniformBufferObject {
    mat4 invView;
    mat4 invProj;
} ubo;

struct Ray {
    vec3 origin;
    vec3 direction;
    vec4 invDirection;
    float payload;
};

struct AABB {
    vec3 lo;
    vec3 hi;
};

bool IntersectAABB(Ray ray, AABB aabb, out float lo, out float hi) {
    float tx1 = (aabb.lo.x - ray.origin.x) * ray.invDirection.x;
    float tx2 = (aabb.hi.x - ray.origin.x) * ray.invDirection.x;
    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (aabb.lo.y - ray.origin.y) * ray.invDirection.y;
    float ty2 = (aabb.hi.y - ray.origin.y) * ray.invDirection.y;
    tmin = max(min(ty1, ty2), tmin);
    tmax = min(max(ty1, ty2), tmax);

    float tz1 = (aabb.lo.z - ray.origin.z) * ray.invDirection.z;
    float tz2 = (aabb.hi.z - ray.origin.z) * ray.invDirection.z;
    tmin = max(min(tz1, tz2), tmin);
    tmax = min(max(tz1, tz2), tmax);

    lo = tmin;
    hi = tmax;
    return tmax >= tmin && tmax > 0.0;
}

float sampleDensity(vec3 position) {
    return 1.0;
}

float march(Ray ray, float tmin, float tmax) {
    float totalDistance = tmax - tmin;
    float totalDensity = 0.0;
    float distanceTraveled = 0.0;

    float stepSize = totalDistance / NUM_STEPS;
    while (distanceTraveled < totalDistance) {
        vec3 position = ray.origin + ray.direction * distanceTraveled;
        totalDensity += sampleDensity(position) * stepSize;
        distanceTraveled += stepSize;
    }

    float transmittance = exp(-totalDensity);
    return transmittance;
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main() 
{
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dispatchSize = ivec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    
    if (id.x >= dispatchSize.x || id.y >= dispatchSize.y) return;

    AABB aabb;
    aabb.lo = vec3(-1.0);
    aabb.hi = vec3(1.0);

    vec2 pixelCenter = vec2(float(id.x) + 0.5, float(id.y) + 0.5);
    vec2 screenSize = vec2(float(dispatchSize.x), float(dispatchSize.y));
    vec2 uv = (pixelCenter / screenSize) * 2.0 - 1.0;
    uv.y = -uv.y;
    vec3 origin = (ubo.invView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec4 target = ubo.invProj * vec4(uv, 1.0, 1.0);
    vec4 direction = ubo.invView * vec4(normalize(target.xyz), 0.0);

    Ray ray;
    ray.origin = origin;
    ray.direction = direction.xyz;
    ray.invDirection = vec4(1.0) / direction;
    ray.payload = 0.0;

    float tmin, tmax;
    if(IntersectAABB(ray, aabb, tmin, tmax)) {
        float transmittance = march(ray, tmin, tmax);

        vec3 color = imageLoad(outputImage, id).rgb;
        //color = mix(color, vec3(1.0), 0.1);
        color *= transmittance;
        imageStore(outputImage, id, vec4(color, 1.0));
    }  
}