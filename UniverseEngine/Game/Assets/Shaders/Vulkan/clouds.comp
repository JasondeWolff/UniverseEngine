#version 450
#extension GL_KHR_vulkan_glsl: enable

#define MAX_PRIMARY_STEPS_HORIZONTAL 64
#define MAX_PRIMARY_STEPS_VERTICAL 32
#define SECONDARY_STEPS 5

layout (binding = 0, rgba16f) uniform image2D outputImage;
layout (binding = 1) uniform sampler2D depthImage;

layout (binding = 2) uniform sampler3D noise;
layout (binding = 3) uniform sampler3D sdf;

layout(binding = 4) uniform UniformBufferObject {
    mat4 invView;
    mat4 invProj;

    vec4 lightDir;
    vec4 lightColor;

    vec4 cloudWeatherOffset;
    vec4 cloudDetailOffset;
    vec4 cloudRoughOffset;
    float cloudWeatherScale;
    float cloudDetailScale;
    float cloudRoughScale;

    float cloudWeatherDensityThreshold;
    float cloudDetailDensityThreshold;
    float cloudRoughDensityThreshold;
    float cloudDensityMultiplier;

    float lightAbsorbtion;
    float eccentricity;
    float aoStrength;

    float zNear;
    float zFar;

    bool sdfDebug;
    float sdfFactor;
    float minTransmittance;

    float PADDING0;
} ubo;

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 invDirection;
};

struct AABB {
    vec3 lo;
    vec3 hi;
    vec3 size;
};

float LinearDepth(float d)
{
    return ubo.zNear * ubo.zFar / (ubo.zFar + d * (ubo.zNear - ubo.zFar));
}

bool IntersectAABB(Ray ray, AABB aabb, out float lo, out float hi) {
    float tx1 = (aabb.lo.x - ray.origin.x) * ray.invDirection.x;
    float tx2 = (aabb.hi.x - ray.origin.x) * ray.invDirection.x;
    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (aabb.lo.y - ray.origin.y) * ray.invDirection.y;
    float ty2 = (aabb.hi.y - ray.origin.y) * ray.invDirection.y;
    tmin = max(min(ty1, ty2), tmin);
    tmax = min(max(ty1, ty2), tmax);

    float tz1 = (aabb.lo.z - ray.origin.z) * ray.invDirection.z;
    float tz2 = (aabb.hi.z - ray.origin.z) * ray.invDirection.z;
    tmin = max(min(tz1, tz2), tmin);
    tmax = min(max(tz1, tz2), tmax);

    lo = tmin;
    hi = tmax;
    return tmax >= tmin && tmax > 0.0;
}

float remap(float v, float minOld, float maxOld, float minNew, float maxNew) {
    v = clamp(v, minOld, maxOld);
    return minNew + (((v - minOld) / (maxOld - minOld)) * (maxNew - minNew));
}

float sampleSDF(vec3 position) {
    return ubo.sdfFactor * texture(sdf, position * ubo.cloudWeatherScale * 0.01 + ubo.cloudWeatherOffset.xyz * 0.01).r / (ubo.cloudWeatherScale * 0.01);
}

float falloffWeight(vec3 position, AABB aabb) {
     const float containerEdgeFadeDst = 1.5;
    float dstFromEdgeX = min(containerEdgeFadeDst, min(position.x - aabb.lo.x, aabb.hi.x - position.x));
    float dstFromEdgeZ = min(containerEdgeFadeDst, min(position.z - aabb.lo.z, aabb.hi.z - position.z));
    float edgeWeight = min(dstFromEdgeZ, dstFromEdgeX) / containerEdgeFadeDst;

    float gMin = 0.2;
    float gMax = 0.7;
    float heightPercent = (position.y - aabb.lo.y) / aabb.size.y;
    float heightGradient = clamp(remap(heightPercent, 0.0, gMin, 0, 1), 0.0, 1.0) * clamp(remap(heightPercent, 1, gMax, 0, 1), 0.0, 1.0);

    return edgeWeight * heightGradient;
}

float sampleBaseDensity(vec3 position, AABB aabb, float lod) {
    if (ubo.sdfDebug) {
        return sampleSDF(position);
    }

    vec3 weatherUV = position * ubo.cloudWeatherScale * 0.01 + ubo.cloudWeatherOffset.xyz * 0.01;
    vec3 roughUV = position * ubo.cloudRoughScale * 0.01 + ubo.cloudRoughOffset.xyz * 0.01;
    float weather = textureLod(noise, weatherUV, lod).g;
    float roughDensity = textureLod(noise, roughUV, lod).r;
    weather = max(weather - ubo.cloudWeatherDensityThreshold, 0.0);
    roughDensity = max(roughDensity - ubo.cloudRoughDensityThreshold, 0.0) * ubo.cloudDensityMultiplier;

    return weather * roughDensity;
}

float sampleFullDensity(vec3 position, AABB aabb, float lod) {
    if (ubo.sdfDebug) {
        return sampleSDF(position);
    }

    float heightPercent = (position.y - aabb.lo.y) / aabb.size.y;

    vec3 detailUV = position * ubo.cloudDetailScale * 0.01 + ubo.cloudDetailOffset.xyz * 0.01;
    float detail = textureLod(noise, detailUV, lod).b;    
    detail = max(detail - ubo.cloudDetailDensityThreshold, 0.0) * heightPercent * heightPercent;
    
    float density = sampleBaseDensity(position, aabb, lod) - detail;
    return density * falloffWeight(position, aabb);
}

float henyeyGreenstein(float cosAngle, float eccentricity) {
    float eccentricity2 = eccentricity * eccentricity;
    return ((1.0 - eccentricity2) / pow((1.0 + eccentricity2 - 2.0 * eccentricity * cosAngle), 3.0 / 2.0)) / 4.0 * 3.1415;
}

float phase(float cosAngle) {
    return henyeyGreenstein(cosAngle, ubo.eccentricity);
}

float beer(float d) {
    return exp(-d * ubo.lightAbsorbtion);
}

float magnus(float d) {
    return max(exp(-d * ubo.lightAbsorbtion), exp(-d * ubo.lightAbsorbtion * 0.25) * 0.7);
}

vec3 lightMarch(vec3 position, AABB aabb) {
    vec3 L = -normalize(ubo.lightDir.xyz);

    Ray ray;
    ray.origin = position;
    ray.direction = L;
    ray.invDirection = vec3(1.0) / L;

    float tmin, tmax;
    IntersectAABB(ray, aabb, tmin, tmax);
    float distanceThroughCloud = tmax;
    float stepSize = distanceThroughCloud / SECONDARY_STEPS;

    float totalDensity = 0.0;
    for (int i = 0; i < SECONDARY_STEPS; i++) {
        position += ray.direction * stepSize;
        totalDensity += max(0.0, sampleFullDensity(position, aabb, 0.0) * stepSize);
    }

    float transmittance = magnus(totalDensity);
    return transmittance * ubo.lightColor.rgb;
}

float AABBAltitudeDistance(Ray ray, AABB aabb) {
    if (ray.origin.y < aabb.lo.y) return aabb.lo.y - ray.origin.y;
    if (ray.origin.y > aabb.hi.y) return ray.origin.y - aabb.hi.y;
    return 0.0;
}

vec4 march(Ray ray, float tmin, float tmax, float depth, AABB aabb) {
    float distanceToCloud = max(tmin, 0.0);
    float maxDistanceThroughCloud = min(AABBAltitudeDistance(ray, aabb) * 3.0 + 600.0, 1200.0);
    float distanceThroughCloud = min(min(depth, tmax) - distanceToCloud, maxDistanceThroughCloud);
    float uniformStepSize = distanceThroughCloud / mix(MAX_PRIMARY_STEPS_HORIZONTAL, MAX_PRIMARY_STEPS_VERTICAL, abs(ray.direction.y));

    float transmittance = 1.0;
    vec3 scattering = vec3(0.0);

    float cosAngle = dot(ray.direction, -normalize(ubo.lightDir.xyz)); 
    float phaseVal = phase(cosAngle);

    float travelledDistance = 0.0;
    while (travelledDistance < distanceThroughCloud) {
        vec3 position = ray.origin + ray.direction * (distanceToCloud + travelledDistance);
        float heightPercent = (position.y - aabb.lo.y) / aabb.size.y;
        float stepSize = max(sampleSDF(position), uniformStepSize);

        float density = sampleFullDensity(position, aabb, 0.0);

        if (density > 0.0) {
            float loddedDensity = density * 14.0;
            float depthProbability = pow(loddedDensity, mix(2.0, 0.5, transmittance));
            float ao = mix(1.0, depthProbability, ubo.aoStrength);
            vec3 lighting = ao * lightMarch(position, aabb);

            vec3 sampledScattering = density * lighting * phaseVal * stepSize;
            float sampledTransmittance = magnus(density * stepSize);

            scattering += sampledScattering * transmittance;
            transmittance *= sampledTransmittance;

            if (transmittance <= ubo.minTransmittance) {
                break;
            }
        }

        travelledDistance += stepSize;
    }

    return vec4(scattering, transmittance);
}

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dispatchSize = ivec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    
    if (id.x >= dispatchSize.x || id.y >= dispatchSize.y) return;

    AABB aabb;
    aabb.lo = vec3(-50000.0, 0.0 + 100.0, -50000.0);
    aabb.hi = vec3(50000.0, 200.0 + 100.0, 50000.0);
    aabb.size = (aabb.hi - aabb.lo);

    vec2 pixelCenter = vec2(float(id.x) + 0.5, float(id.y) + 0.5);
    vec2 screenSize = vec2(float(dispatchSize.x), float(dispatchSize.y));
    vec2 uv = (pixelCenter / screenSize) * 2.0 - 1.0;
    uv.y = -uv.y;
    vec3 origin = (ubo.invView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec4 target = ubo.invProj * vec4(uv, 1.0, 1.0);
    vec4 direction = ubo.invView * vec4(normalize(target.xyz), 0.0);

    float nonlinearDepth = texture(depthImage, pixelCenter / vec2(dispatchSize)).r;
    float depth = LinearDepth(nonlinearDepth);

    Ray ray;
    ray.origin = origin;
    ray.direction = direction.xyz;
    ray.invDirection = vec3(1.0) / direction.xyz;

    float tmin, tmax;
    if(IntersectAABB(ray, aabb, tmin, tmax)) {
        vec4 marchResult = march(ray, tmin, tmax, depth, aabb);
        imageStore(outputImage, id, marchResult);
    } else {
        imageStore(outputImage, id, vec4(0.0, 0.0, 0.0, 1.0));
    }
}