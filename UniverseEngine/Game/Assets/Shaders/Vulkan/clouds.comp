#version 450
#extension GL_KHR_vulkan_glsl: enable

#define PRIMARY_STEPS 50
#define SECONDARY_STEPS 4
#define MIN_TRANSMITTANCE 0.1

layout (binding = 0, rgba8) uniform image2D outputImage;
layout (binding = 1) uniform sampler2D depthImage;

layout (binding = 2) uniform sampler3D noise;

layout(binding = 3) uniform UniformBufferObject {
    mat4 invView;
    mat4 invProj;

    vec4 lightDir;
    vec4 lightColor;

    vec4 cloudOffset;
    float cloudScale;
    float cloudDensityThreshold;
    float cloudDensityMultiplier;

    float forwardScattering;
    float backwardScattering;
    float baseBrightness;
    float phaseFactor;

    float lightAbsorbtion;
    float indirectLightAbsorbtion;
    float darknessThreshold;

    float zNear;
    float zFar;
} ubo;

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 invDirection;
    float payload;
};

struct AABB {
    vec3 lo;
    vec3 hi;
};

float LinearDepth(float d)
{
    return ubo.zNear * ubo.zFar / (ubo.zFar + d * (ubo.zNear - ubo.zFar));
}

bool IntersectAABB(Ray ray, AABB aabb, out float lo, out float hi) {
    float tx1 = (aabb.lo.x - ray.origin.x) * ray.invDirection.x;
    float tx2 = (aabb.hi.x - ray.origin.x) * ray.invDirection.x;
    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (aabb.lo.y - ray.origin.y) * ray.invDirection.y;
    float ty2 = (aabb.hi.y - ray.origin.y) * ray.invDirection.y;
    tmin = max(min(ty1, ty2), tmin);
    tmax = min(max(ty1, ty2), tmax);

    float tz1 = (aabb.lo.z - ray.origin.z) * ray.invDirection.z;
    float tz2 = (aabb.hi.z - ray.origin.z) * ray.invDirection.z;
    tmin = max(min(tz1, tz2), tmin);
    tmax = min(max(tz1, tz2), tmax);

    lo = tmin;
    hi = tmax;
    return tmax >= tmin && tmax > 0.0;
}

float henyey(float a, float g) {
    float g2 = g*g;
    return (1-g2) / (4*3.1415*pow(1+g2-2*g*(a), 1.5));
}

float phase(float a) {
    float blend = 0.5;
    float hgBlend = henyey(a, ubo.forwardScattering) * (1.0 - blend) + henyey(a, -ubo.backwardScattering) * blend;
    return ubo.baseBrightness + hgBlend * ubo.phaseFactor;
}

float beer(float d) {
    return exp(-d);
}

float sampleDensity(vec3 position) {
    float density = texture(noise, position * ubo.cloudScale * 0.01 + ubo.cloudOffset.xyz * 0.01).r;
    density = max(density - ubo.cloudDensityThreshold, 0.0) * ubo.cloudDensityMultiplier;
    return density;
}

float lightMarch(vec3 position, AABB aabb) {
    vec3 L = -normalize(ubo.lightDir.xyz);

    Ray ray;
    ray.origin = position;    
    ray.direction = L;
    ray.invDirection = vec3(1.0) / L;

    float tmin, tmax;
    IntersectAABB(ray, aabb, tmin, tmax);
    float distanceThroughCloud = tmax;
    float stepSize = distanceThroughCloud / SECONDARY_STEPS;

    float totalDensity = 0.0;
    for (int i = 0; i < SECONDARY_STEPS; i++) {
        position += L * stepSize;
        totalDensity += max(0.0, sampleDensity(position) * stepSize);
    }

    float transmittance = exp(-totalDensity * ubo.lightAbsorbtion);
    return ubo.darknessThreshold + transmittance * (1.0 - ubo.darknessThreshold);
}

vec2 march(Ray ray, float tmin, float tmax, float depth, AABB aabb) {
    float distanceToCloud = max(tmin, 0.0);
    float distanceThroughCloud = min(min(depth, tmax) - distanceToCloud, 100.0);

    float transmittance = 1.0;
    float lightEnergy = 0.0;

    float cosAngle = dot(ray.direction, -ubo.lightDir.xyz);
    float phaseVal = phase(cosAngle);

    float uniformStepSize = distanceThroughCloud / PRIMARY_STEPS;
    float minStepSize = uniformStepSize * 0.1;
    float maxStepSize = uniformStepSize * 3.0;
    const float badDensityThreshold = 0.1;

    float stepSize = uniformStepSize;
    for (int i = 0; i < PRIMARY_STEPS; i++) {
        vec3 position = ray.origin + ray.direction * (distanceToCloud + i * stepSize);
        float density = sampleDensity(position);

        float stepSizeFactor = (1.0 - density) + (1.0 - badDensityThreshold);
        stepSize = clamp(stepSize * stepSizeFactor, minStepSize, maxStepSize);

        if (density > 0.0) {
            float lightTransmittance = lightMarch(position, aabb);
            lightEnergy += density * stepSize * transmittance * lightTransmittance * phaseVal;
            transmittance *= exp(-density * stepSize * ubo.indirectLightAbsorbtion);

            if (transmittance < MIN_TRANSMITTANCE) {
                break;
            }
        }

        if (i * stepSize > distanceThroughCloud) {
            break;
        }
    }

    return vec2(transmittance, lightEnergy);
}

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
void main() 
{
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dispatchSize = ivec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy);
    
    if (id.x >= dispatchSize.x || id.y >= dispatchSize.y) return;

    AABB aabb;
    aabb.lo = vec3(-1000.0, -20.0, -1000.0);
    aabb.hi = vec3(1000.0, 20.0, 1000.0);

    vec2 pixelCenter = vec2(float(id.x) + 0.5, float(id.y) + 0.5);
    vec2 screenSize = vec2(float(dispatchSize.x), float(dispatchSize.y));
    vec2 uv = (pixelCenter / screenSize) * 2.0 - 1.0;
    uv.y = -uv.y;
    vec3 origin = (ubo.invView * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec4 target = ubo.invProj * vec4(uv, 1.0, 1.0);
    vec4 direction = ubo.invView * vec4(normalize(target.xyz), 0.0);

    float nonlinearDepth = texture(depthImage, pixelCenter / vec2(dispatchSize)).r;
    float depth = LinearDepth(nonlinearDepth);

    Ray ray;
    ray.origin = origin;
    ray.direction = direction.xyz;
    ray.invDirection = vec3(1.0) / direction.xyz;
    ray.payload = 0.0;

    float tmin, tmax;
    if(IntersectAABB(ray, aabb, tmin, tmax)) {
        vec3 color = imageLoad(outputImage, id).rgb;

        vec2 marchResult = march(ray, tmin, tmax, depth, aabb);
        color = color * marchResult.x + marchResult.y * ubo.lightColor.rgb;
        imageStore(outputImage, id, vec4(color, 1.0));
    }  
}