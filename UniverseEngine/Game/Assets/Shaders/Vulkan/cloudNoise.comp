#version 450
#extension GL_KHR_vulkan_glsl: enable

// Inspired by https://www.shadertoy.com/view/3dVXDc
#define UI0 1597334673U
#define UI1 3812015801U
#define UI2 uvec2(UI0, UI1)
#define UI3 uvec3(UI0, UI1, 2798796415U)
#define UIF (1.0 / float(0xffffffffU))

layout (binding = 0, rgba8) uniform image3D noise;

layout(binding = 1) uniform UniformBufferObject {
    float size;
} ubo;

vec3 hash33(vec3 p) {
	uvec3 q = uvec3(ivec3(p)) * UI3;
	q = (q.x ^ q.y ^ q.z)*UI3;
	return -1.0 + 2.0 * vec3(q) * UIF;
}

float remap(float x, float b, float a, float c, float d) {
    return (((x - a) / (b - a)) * (d - c)) + c;
}

float gradientNoise(vec3 x, float freq) {
    vec3 p = floor(x);
    vec3 w = fract(x);
    
    vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
    
    vec3 ga = hash33(mod(p + vec3(0.0, 0.0, 0.0), freq));
    vec3 gb = hash33(mod(p + vec3(1.0, 0.0, 0.0), freq));
    vec3 gc = hash33(mod(p + vec3(0.0, 1.0, 0.0), freq));
    vec3 gd = hash33(mod(p + vec3(1.0, 1.0, 0.0), freq));
    vec3 ge = hash33(mod(p + vec3(0.0, 0.0, 1.0), freq));
    vec3 gf = hash33(mod(p + vec3(1.0, 0.0, 1.0), freq));
    vec3 gg = hash33(mod(p + vec3(0.0, 1.0, 1.0), freq));
    vec3 gh = hash33(mod(p + vec3(1.0, 1.0, 1.0), freq));
    
    float va = dot(ga, w - vec3(0.0, 0.0, 0.0));
    float vb = dot(gb, w - vec3(1.0, 0.0, 0.0));
    float vc = dot(gc, w - vec3(0.0, 1.0, 0.0));
    float vd = dot(gd, w - vec3(1.0, 1.0, 0.0));
    float ve = dot(ge, w - vec3(0.0, 0.0, 1.0));
    float vf = dot(gf, w - vec3(1.0, 0.0, 1.0));
    float vg = dot(gg, w - vec3(0.0, 1.0, 1.0));
    float vh = dot(gh, w - vec3(1.0, 1.0, 1.0));
	
    return va + 
           u.x * (vb - va) + 
           u.y * (vc - va) + 
           u.z * (ve - va) + 
           u.x * u.y * (va - vb - vc + vd) + 
           u.y * u.z * (va - vc - ve + vg) + 
           u.z * u.x * (va - vb - ve + vf) + 
           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);
}

float worleyNoise(vec3 uv, float freq) {    
    vec3 id = floor(uv);
    vec3 p = fract(uv);
    
    float minDist = 10000.0;
    for (float x = -1.0; x <= 1.0; x++) {
        for(float y = -1.0; y <= 1.0; y++) {
            for(float z = -1.0; z <= 1.0; z++) {
                vec3 offset = vec3(x, y, z);
            	vec3 h = hash33(mod(id + offset, vec3(freq))) * 0.5 + 0.5;
    			h += offset;
            	vec3 d = p - h;
           		minDist = min(minDist, dot(d, d));
            }
        }
    }
    
    return 1.0 - minDist;
}

float perlinfbm(vec3 p, float freq, int octaves) {
    float G = exp2(-0.85);
    float amp = 1.0;
    float noise = 0.0;
    for (int i = 0; i < octaves; i++) {
        noise += amp * gradientNoise(p * freq, freq);
        freq *= 2.0;
        amp *= G;
    }
    
    return noise;
}

float worleyFbm(vec3 p, float freq) {
    return worleyNoise(p*freq, freq) * 0.625 +
        	 worleyNoise(p * freq * 2.0, freq * 2.0) * 0.25 +
        	 worleyNoise(p * freq * 4.0, freq * 4.0) * 0.125;
}

float perlinWorley(vec3 p, float freq, float pfbm) {
    float g = worleyFbm(p, freq);
    float b = worleyFbm(p, freq * 2.0);
    float a = worleyFbm(p, freq * 4.0);

    float perlinWorley = remap(pfbm, 1.0, 0.0, g, 1.0);

    vec3 worley = vec3(g, b, a);
    float wfbm = worley.x * 0.625 +
        		 worley.y * 0.125 +
        		 worley.z * 0.25;

    return remap(perlinWorley, 1.0, wfbm - 1.0, 0.0, 1.0);
}

float genRoughNoise(vec3 p) {
    float pfbm = mix(1.0, perlinfbm(p, 4.0, 7), 0.5);
    pfbm = abs(pfbm * 2.0 - 1.0);

    float cloud = perlinWorley(p, 4.0, pfbm);
    return cloud;
}

float genDetailNoise(vec3 p) {
    float pfbm = mix(1.0, perlinfbm(p, 4.0, 7), 0.5);
    pfbm = abs(pfbm * 2.0 - 1.0);

    float cloud = perlinWorley(p, 10.0, pfbm);
    return cloud;
}

float genWeatherNoise(vec3 p) {
    p.y = 0.0;
    float pfbm = mix(1.0, perlinfbm(p, 1.0, 7), 0.5);
    pfbm = abs(pfbm * 2.0 - 1.0);
    pfbm = 1.0 - remap(pfbm, 0.15, 0.25, 0.0, 1.0);

    return pfbm;
}

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main() 
{
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 dispatchSize = ivec3(gl_WorkGroupSize.xyz * gl_NumWorkGroups.xyz);
    
    if (id.x >= dispatchSize.x || id.y >= dispatchSize.y || id.z >= dispatchSize.z) return;

    vec3 p = vec3(id) / vec3(dispatchSize);
    imageStore(noise, id, vec4(vec3(genRoughNoise(p), genWeatherNoise(p), genDetailNoise(p)), 1.0));
}